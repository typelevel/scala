---
layout: homepage
order: 2
title: Home
---

# Typelevel Scala

## What is this repository?

This [repository](https://github.com/typelevel/scala) contains the [Typelevel](http://typelevel.org/) [fork](http://typelevel.org/blog/2014/09/02/typelevel-scala.html) of the Scala compiler.

Typelevel Scala is a conservative, collaborative and binary compatible fork of [Lightbend Scala](https://github.com/scala/scala). The intention is for it to provide early access to bug fixes and enhancements of the Scala toolchain which are of particular interest to [projects](http://typelevel.org/projects/) which use the “Typelevel style” — extensive use of type classes, generic programming and exploitation of the distinctive features of Scala’s type system such as higher-kinded, dependent and singleton types.

## Relationship with Lightbend Scala

Typelevel Scala releases will be made in lockstep with Lightbend Scala and will by default generate code which is binary compatible with code generated by Lightbend Scala. Code generated with Typelevel Scala can be freely linked against binary dependencies generated with Lightbend Scala and vice versa. This allows Typelevel Scala features and fixes to be used with minimal risk.

The policy for inclusion of a fix or a feature in a Typelevel Scala release is as follows,

* It must be first submitted as a pull request to the corresponding version of Lightbend Scala.
* It must have a reasonable likelihood of being merged in a future Lightbend Scala release.
* It must offer a significant fix or feature for which there is no reasonable alternative or workaround.
* It must maintain binary compatibility with Lightbend Scala unless a binary change is the primary motivation for the addition.

The aim of this policy is to keep Typelevel Scala as close as possible to Lightbend Scala whilst still providing significant benefits to people who are affected by the issues it addresses. The requirement that all changes exist as a pull request against Lightbend Scala first and have a reasonable chance of being merged in a future Lightbend Scala release is intended to encourage collaboration and convergence between Typelevel and Lightbend Scala contributors.

Apart from the first criterion there is room for interpretation — after all, what counts as “reasonable”? Where the letter of the policy is unclear we appeal to its spirit — we want access to these features and fixes in our projects now and for that to be feasible it is essential that we maintain the greatest possible degree of binary interoperability with the rest of the Scala ecosystem.

## Should I use Typelevel Scala? In production?

The baseline for Typelevel Scala is the corresponding version of Lightbend Scala. Every bugfix or feature addition to Typelevel Scala exists as a pull request against that Lightbend Scala version, so will have been passed by the full Scala toolchain test suite and, in most cases, will have been reviewed by the Lightbend Scala compiler team.

If you are affected by one of the bugs which Typelevel Scala addresses then you will have to weigh the risks and costs of using a compiler with the bug (perhaps with workarounds using unnecessarily complex encodings, macros or compiler plugins), against the risks and costs of using an alternative Scala distribution which fixes that bug. Only you can make that call. The same considerations apply to the additional features that Typelevel Scala supports.

More generally there are many reasons why you might want to use and contribute to Typelevel Scala,

* You want to evaluate or contribute to a feature or fix.
* You want to explore how new language features interact with existing libraries.
* You want to explore new library designs enabled by new language features.
* You want to propose new language features motiviated by your experiences with library design.
* You want to contribute a feature or fix to Lightbend/Typelevel Scala and want to evaluate its interactions with other pending features and fixes.

Within the Typelevel family of projects we are particularly excited by the prospect of being able to coevolve libraries along with the language and believe that this is one of the best ways to keep the language fresh and relevant to practitioners.


If you would like to learn more, please read our [Getting Started](getting_started) section.
